<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dash-Plus Notes</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        /* Task row styling */
        .task-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            margin-bottom: 8px;
            background: white;
            transition: all 0.2s;
        }

        .task-row:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
        }

        .task-row.done {
            opacity: 0.6;
            text-decoration: line-through;
        }

        .task-status {
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            min-width: 24px;
            text-align: center;
            user-select: none;
        }

        .task-content {
            flex: 1;
            cursor: pointer;
        }

        .task-content input {
            width: 100%;
            padding: 6px;
            border: 2px solid #3b82f6;
            border-radius: 4px;
        }

        .task-due {
            font-size: 12px;
            color: #666;
        }

        .task-delete {
            padding: 4px 8px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .task-delete:hover {
            background: #dc2626;
        }

        /* Input for new task */
        #newTaskInput {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            margin-bottom: 16px;
        }

        #newTaskInput:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            font-size: 12px;
            color: #666;
        }

        .task-delete {
            padding: 4px 8px;
        }

        .dark .task-row {
            background: #1f2937;
            border-color: #374151;
        }

        .dark .task-row:hover {
            background: #111827;
        }

        .dark .task-content {
            color: #f3f4f6;
        }

        .dark .task-due {
            color: #9ca3af;
        }

        .dark #newTaskInput {
            background: #1f2937;
            color: #f3f4f6;
            border-color: #374151;
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100">
    <div class="container">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <h1>dash-plus</h1>
            <button onclick="toggleTheme()" style="padding: 8px 12px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer;">
                <span id="themeIcon">ðŸŒ™</span>
            </button>
        </div>

        <div class="stats">
            <span>Total: <strong id="totalCount">0</strong></span>
            <span>Active: <strong id="activeCount">0</strong></span>
            <span>Done: <strong id="doneCount">0</strong></span>
            <span style="margin-left: auto;">
                <button onclick="toggleArchiveView()" style="padding: 4px 8px; background: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                    ðŸ“¦ <span id="archiveLabel">Archived</span> (<span id="archivedCount">0</span>)
                </button>
            </span>
        </div>

        <input
            id="newTaskInput"
            type="text"
            placeholder="Type a task and press Enter..."
            autocomplete="off"
        />

        <div id="taskList"></div>
        <div id="archivedList" style="display: none; margin-top: 40px; padding-top: 20px; border-top: 2px solid #e5e7eb;">
            <h2 style="font-size: 16px; font-weight: bold; margin-bottom: 12px;">Archived Tasks</h2>
            <div id="archivedTaskList"></div>
        </div>
    </div>

    <script>
        // State management
        const STORAGE_KEY = 'dashplus-tasks';
        const SYMBOLS = {
            active: '-',
            waiting: 'â†’',
            delegated: 'â†',
            reference: 'Î”',
            done: '+'
        };
        const STATUS_CYCLE = ['active', 'waiting', 'delegated', 'reference', 'done'];

        let tasks = [];
        let showArchived = false;

        // Load from localStorage
        function load() {
            const stored = localStorage.getItem(STORAGE_KEY);
            tasks = stored ? JSON.parse(stored) : [];
        }

        // Save to localStorage
        function save() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(tasks));
        }

        // Render all tasks
        function render() {
            const listEl = document.getElementById('taskList');
            const archivedListEl = document.getElementById('archivedTaskList');
            const archivedContainerEl = document.getElementById('archivedList');

            listEl.innerHTML = '';
            archivedListEl.innerHTML = '';

            const activeTasks = tasks.filter(t => !t.archived);
            const archivedTasks = tasks.filter(t => t.archived);

            // Render active tasks
            activeTasks.forEach((task, idx) => {
                const realIdx = tasks.indexOf(task);
                const taskRow = createTaskElement(task, realIdx);
                listEl.appendChild(taskRow);
            });

            // Render archived tasks (if showing archive view)
            if (showArchived) {
                archivedTasks.forEach((task, idx) => {
                    const realIdx = tasks.indexOf(task);
                    const taskRow = createTaskElement(task, realIdx, true);
                    archivedListEl.appendChild(taskRow);
                });
                archivedContainerEl.style.display = archivedTasks.length > 0 ? 'block' : 'none';
            } else {
                archivedContainerEl.style.display = 'none';
            }

            updateStats();
        }

        // Create task row element
        function createTaskElement(task, idx, isArchived = false) {
            const taskRow = document.createElement('div');
            taskRow.className = `task-row ${task.status === 'done' ? 'done' : ''}`;
            taskRow.dataset.idx = idx;

            // Status symbol
            const statusEl = document.createElement('span');
            statusEl.className = 'task-status';
            statusEl.textContent = SYMBOLS[task.status] || '-';
            if (!isArchived) {
                statusEl.onclick = (e) => {
                    e.stopPropagation();
                    cycleStatus(idx);
                };
            }
            taskRow.appendChild(statusEl);

            // Content
            const contentEl = document.createElement('span');
            contentEl.className = 'task-content';
            contentEl.textContent = task.content;
            if (!isArchived) {
                contentEl.ondblclick = (e) => {
                    e.stopPropagation();
                    startEdit(idx);
                };
            }
            taskRow.appendChild(contentEl);

            // Due date (if set)
            if (task.dueDate) {
                const dueEl = document.createElement('span');
                dueEl.className = 'task-due';
                dueEl.textContent = task.dueDate;
                taskRow.appendChild(dueEl);
            }

            // Action button (Archive or Unarchive)
            const actionBtn = document.createElement('button');
            actionBtn.className = 'task-delete';
            actionBtn.textContent = isArchived ? 'â†©' : 'ðŸ“¦';
            actionBtn.title = isArchived ? 'Unarchive' : 'Archive';
            actionBtn.onclick = (e) => {
                e.stopPropagation();
                toggleArchive(idx);
            };
            taskRow.appendChild(actionBtn);

            return taskRow;
        }

        // Create new task
        function createTask(content) {
            if (!content.trim()) return;
            tasks.push({
                id: Date.now(),
                content: content.trim(),
                status: 'active',
                dueDate: null,
                archived: false,
                createdAt: new Date().toISOString()
            });
            save();
            render();
        }

        // Start inline editing
        function startEdit(idx) {
            const taskRow = document.querySelector(`[data-idx="${idx}"]`);
            const contentEl = taskRow.querySelector('.task-content');

            const input = document.createElement('input');
            input.type = 'text';
            input.value = tasks[idx].content;

            input.onblur = () => finishEdit(idx, input.value);
            input.onkeydown = (e) => {
                e.stopPropagation();
                if (e.key === 'Enter') finishEdit(idx, input.value);
                if (e.key === 'Escape') render();
            };

            contentEl.replaceWith(input);
            input.focus();
            input.select();
        }

        // Finish editing
        function finishEdit(idx, newContent) {
            if (newContent.trim()) {
                tasks[idx].content = newContent.trim();
            }
            save();
            render();
        }

        // Cycle status
        function cycleStatus(idx) {
            const current = STATUS_CYCLE.indexOf(tasks[idx].status);
            const next = (current + 1) % STATUS_CYCLE.length;
            tasks[idx].status = STATUS_CYCLE[next];
            save();
            render();
        }

        // Toggle archive state
        function toggleArchive(idx) {
            tasks[idx].archived = !tasks[idx].archived;
            save();
            render();
        }

        // Toggle archive view
        function toggleArchiveView() {
            showArchived = !showArchived;
            render();
        }

        // Update statistics
        function updateStats() {
            const activeTasks = tasks.filter(t => !t.archived);
            const total = activeTasks.length;
            const active = activeTasks.filter(t => t.status !== 'done').length;
            const done = activeTasks.filter(t => t.status === 'done').length;
            const archived = tasks.filter(t => t.archived).length;

            document.getElementById('totalCount').textContent = total;
            document.getElementById('activeCount').textContent = active;
            document.getElementById('doneCount').textContent = done;
            document.getElementById('archivedCount').textContent = archived;
        }

        // Theme toggle
        function toggleTheme() {
            document.documentElement.classList.toggle('dark');
            localStorage.setItem('theme', document.documentElement.classList.contains('dark') ? 'dark' : 'light');
        }

        // Initialize
        function init() {
            load();

            // Load theme preference
            const theme = localStorage.getItem('theme') || 'light';
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
            }

            // Wire up new task input
            const newTaskInput = document.getElementById('newTaskInput');
            newTaskInput.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    createTask(newTaskInput.value);
                    newTaskInput.value = '';
                    newTaskInput.focus();
                }
            };

            render();
            newTaskInput.focus();
        }

        // Start
        init();
    </script>
</body>
</html>
